---
layout: post
title: C#下使用单例模式 
subtitle: C#下使用单例模式 
author: JoVanko
categories: C#
banner:
#   video: 
#   loop: true
#   volume: 0.8
  start_at: 8.5
  image: https://zhaohuanke123.github.io/assets/images/wallhaven-l8rmxq.jpg
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: C# 单例模式
top: 1
sidebar: []
---


一般常见写法，但是不是线程安全的，在多个线程访问 if (instance == null) 时会，同时进入if语句内创建多个Singleton实例。

```csharp
public class Singleton
{
    // 直接初始化单例实例
    private static Singleton instance ;
    public static Singleton Instance
    {
        get
        {
            if (instance != null)
            {
                return instance;
            }

            if (instance == null)
            {
                instance = new Singleton();
            }

            return instance;
        }
    }

    // 私有构造函数
    private Singleton()
    {
        // 这里可以进行一些初始化工作
        Console.WriteLine("Singleton instance created.");
    }

    public void SomeMethod()
    {
        Console.WriteLine("SomeMethod called.");
    }
}
```

我们测试一下：

```csharp
class Program
{
    static void Main()
    {
        // 创建50个线程访问单例实例
        for (int i = 0; i < 50; i++)
        {
            System.Threading.ThreadPool.QueueUserWorkItem((state) =>
            {
                Task.Delay(50).Wait();
                Singleton.Instance.SomeMethod();
            });
        }

        Console.ReadLine();
    }
}

```

结果：

![image](https://zhaohuanke123.github.io/assets/images/CSharp/1702434181028.png)

可以发现有多个实例被创建


简单的线程安全做法

```csharp

public class Singleton
{
    // 直接初始化单例实例
    private static readonly Singleton instance = new Singleton();
    public static Singleton Instance => instance;

    // 私有构造函数
    private Singleton()
    {
        // 这里可以进行一些初始化工作
        Console.WriteLine("Singleton instance created.");
    }

    // 公共属性，用于获取单例实例
}


```
